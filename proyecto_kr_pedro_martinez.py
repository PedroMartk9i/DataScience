# -*- coding: utf-8 -*-
"""Proyecto KR Pedro Martinez

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G75YiPlo1bb5KOlcenOz9E-xvTPzs_Nw
"""

!pip install pyproj

!pip install geopandas

!pip uninstall cython -y
!pip install cython
!pip uninstall cartopy -y
!pip install cartopy

!apt-get -qq install python-cartopy python3-cartopy
!pip uninstall -y shapely    # cartopy and shapely aren't friends (early 2020)
!pip install shapely --no-binary shapely

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import pyproj
import math
import matplotlib.pyplot as plt
import seaborn as sb
import urllib.request
import shapely

# %matplotlib inline
import matplotlib.pyplot as plt
from matplotlib import cm

import numpy as np

import cartopy
import cartopy.crs as ccrs                   # for projections
import cartopy.feature as cfeature           # for features
import cartopy.io.shapereader as shapereader
from cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter
from cartopy.feature.nightshade import Nightshade
import geopandas as gpd
import random
from shapely.geometry import Point, Polygon
import time

ruta = 'https://raw.githubusercontent.com/fmoreno4/cd-files/main/eventos_dengue_2020.csv'
#ruta = 'https://raw.githubusercontent.com/rasief/cartografia/master/melb_data.csv'
df = pd.read_csv(ruta)
df

#Creación de la proyección
P = pyproj.Proj(proj='utm', zone=18, ellps='WGS84', preserve_units=True)

#Se convertirán las coordenadas geográficas a UTM
df['x'], df['y'] = P(df['longitud'], df['latitud'])
df

subplot_kw = dict(projection=ccrs.PlateCarree())

fig, ax = plt.subplots(figsize=(8, 8), subplot_kw=subplot_kw)

ax.scatter(df['longitud'], df['latitud'], zorder=10, c='b', s=10)
plt.show()

#Se carga la cartografía de Floridablanca/Melbourne
url = 'https://raw.githubusercontent.com/fmoreno4/cd-files/main/'

file_list = ["68276_urbano.cpg", "68276_urbano.dbf", "68276_urbano.prj", "68276_urbano.shp", "68276_urbano.shx"]

for file in file_list:
    urllib.request.urlretrieve(url+file, file)

subplot_kw = dict(projection=ccrs.PlateCarree())

fig, ax = plt.subplots(figsize=(8, 8), subplot_kw=subplot_kw)

# Puntos Floridablanca
lower_lon = -73.1215
upper_lon = -73.0732
lower_lat = 7.054
upper_lat = 7.1005

ax.set_extent([lower_lon, upper_lon, lower_lat, upper_lat])

reader = shapereader.Reader('68276_urbano.shp')

for poli in reader.geometries():
    ax.add_geometries([poli], ccrs.PlateCarree(), facecolor='white', edgecolor='gray')

plt.show()

subplot_kw = dict(projection=ccrs.PlateCarree())

fig, ax = plt.subplots(figsize=(8, 8), subplot_kw=subplot_kw)

# Puntos Floridablanca
lower_lon = -73.1215
upper_lon = -73.0732
lower_lat = 7.054
upper_lat = 7.1005

ax.set_extent([lower_lon, upper_lon, lower_lat, upper_lat])

reader = shapereader.Reader('68276_urbano.shp')

for poli in reader.geometries():
    ax.add_geometries([poli], ccrs.PlateCarree(), facecolor='white', edgecolor='gray')

ax.scatter(df['longitud'], df['latitud'], zorder=10, c='b', s=10)

plt.show()

import geopandas as gpd
poligono = gpd.read_file('68276_urbano.shp')

poligono = poligono.to_crs({'init':'epsg:32618'})

#Área del polígono
from shapely.geometry import shape
area= shape(poligono.loc[0,'geometry']).area
print(area)

#Convertir los puntos en tupla y colocarlos en una lista
listaPuntos = []
for i in range(len(df)):
  listaPuntos.append((df.loc[i, "x"], df.loc[i, "y"]))


#Crear la función K
def k_ripley(listaPuntos, distancia, area):
  sum = sumatoria(listaPuntos,100)
  n = len(listaPuntos)
  k = area*sum/n**2
  print("Área: ", area)
  print("Número de puntos: ", n)
  print("Función K-ripley: ", k)

#Crear una función de distancia
def calc_distancia(p1,p2):
  return((p2[0]-p1[0])**2+(p2[1]-p1[1])**2)**0.5

def sumatoria(listaPuntos,distamax):
  n = 0
  for i in range(len(listaPuntos)):
    for j in range(i+1, len(listaPuntos)):
      if calc_distancia(listaPuntos[i], listaPuntos[j]) <= distamax:
        n+=1
  return n;

sum = sumatoria(listaPuntos,100)
n = len(listaPuntos)
k = area*sum/n**2

import shapely

n_puntos = 1262
lista_puntos = []

for i in range(n_puntos):
  while True:
        #Generar puntos
        puntoEje_x = np.random.uniform(poligono.bounds.minx, poligono.bounds.maxx)
        puntoEje_y = np.random.uniform(poligono.bounds.miny, poligono.bounds.maxy)
        punto = shapely.geometry.Point(puntoEje_x [0], puntoEje_y[0])
        punto_shapely = shapely.geometry.Point(puntoEje_x, puntoEje_y)
        if poligono.geometry.contains(punto_shapely).any():
            lista_puntos.append(punto)
            break
Rpuntos_df = gpd.GeoDataFrame(geometry=lista_puntos, crs=poligono.crs)
Rpuntos_df['X'] = Rpuntos_df.geometry.x
Rpuntos_df['Y'] = Rpuntos_df.geometry.y

#Convertir puntos en tupla y almacenarlos en la lista
listaPuntos_aleatorio = []
for i in range(len(Rpuntos_df)):
  listaPuntos_aleatorio.append((Rpuntos_df.loc[i, "X"], Rpuntos_df.loc[i, "Y"]))

fig, ax = plt.subplots(figsize=(10, 10))
poligono.plot(ax=ax, color="white", alpha=0.5, edgecolor='k')

# Gráfica de puntos aleatorios
Rpuntos_df.plot(ax=ax, color='black', markersize=10)
plt.title('Floridablanca map')
plt.axis('equal')
plt.show()

k_ripley(listaPuntos_aleatorio, 100, area)

# Define una función llamada generacion_de_puntos que toma dos argumentos: n_puntos que:
# representa el número de puntos aleatorios que se generarán.
def generacion_de_puntos(n_puntos, poligono):

  lista_puntos = []
  for i in range(n_puntos):
    while True:

          punto_x = np.random.uniform(poligono.bounds.minx, poligono.bounds.maxx)
          punto_y = np.random.uniform(poligono.bounds.miny, poligono.bounds.maxy)
          punto = shapely.geometry.Point(punto_x[0], punto_y[0])
          punto_shapely = shapely.geometry.Point(punto_x, punto_y)
          if poligono.geometry.contains(punto_shapely).any():
              lista_puntos.append(punto)
              break

  Rpuntos_df = gpd.GeoDataFrame(geometry=lista_puntos, crs=poligono.crs)
  Rpuntos_df['X'] = Rpuntos_df.geometry.x
  Rpuntos_df['Y'] = Rpuntos_df.geometry.y
  return (Rpuntos_df)

dfc_1 = generacion_de_puntos(n_puntos, poligono)
dfc_1.drop(columns= ["geometry"], inplace=True)
dfc_1

dfc_2 = generacion_de_puntos(n_puntos, poligono)
dfc_2.drop(columns= ["geometry"], inplace=True)
dfc_2

dfc_3 = generacion_de_puntos(n_puntos, poligono)
dfc_3.drop(columns= ["geometry"], inplace=True)
dfc_3

dfc_4 = generacion_de_puntos(n_puntos, poligono)
dfc_4.drop(columns= ["geometry"], inplace=True)
dfc_4

dfc_5 = generacion_de_puntos(n_puntos, poligono)
dfc_5.drop(columns= ["geometry"], inplace=True)
dfc_5

dfc_6 = generacion_de_puntos(n_puntos, poligono)
dfc_6.drop(columns= ["geometry"], inplace=True)
dfc_6

dfc_7 = generacion_de_puntos(n_puntos, poligono)
dfc_7.drop(columns= ["geometry"], inplace=True)
dfc_7

dfc_8 = generacion_de_puntos(n_puntos, poligono)
dfc_8.drop(columns= ["geometry"], inplace=True)
dfc_8

dfc_9 = generacion_de_puntos(n_puntos, poligono)
dfc_9.drop(columns= ["geometry"], inplace=True)
dfc_9

#Dataframe original
dfc_0 = pd.DataFrame(columns=['X', 'Y'])
dfc_0['X'] = df.x
dfc_0['Y'] = df.y
dfc_0

#Función K en los dataframe

def listaPuntos(dataframe):
  listaPuntos_aleatorio = []
  for i in range(len(dataframe)):
      listaPuntos_aleatorio.append((dataframe.loc[i, "X"], dataframe.loc[i, "Y"]))
  return listaPuntos_aleatorio

#Generamos iteraciones para el nombre de cada dataframe es decir; desde 0 hasta 9 o df0 hasta df9 y generamos una lista de puntos en cada dataframe
for i in range(0, 10):
      nombre_df = f'dfc_{i}'
      dataframe_actual = globals()[nombre_df]
      print("DataFrame",i)
      listaPuntos_aleatorio = listaPuntos(dataframe_actual)
      k_ripley(listaPuntos_aleatorio, 100, area)

#Calculamos el indice de K de ripley de cada dataframe en el que previamente colocamos puntos aleatorios
#Estos se almacenarán en la variable df_resultados
dataframes = {
    'df_OG': dfc_0,
    'dfc_1': dfc_1,
    'dfc_2': dfc_2,
    'dfc_3': dfc_3,
    'dfc_4': dfc_4,
    'dfc_5': dfc_5,
    'dfc_6': dfc_6,
    'dfc_7': dfc_7,
    'dfc_8': dfc_8,
    'dfc_9': dfc_9
}

#Modificación función de Ripley

def distancia(x1,y1,x2,y2):
  return math.sqrt((x2-x1)**2 + (y2-y1)**2)

def k_ripley2 (df, metros, area):
  points = [[x, y] for x, y in zip(df['X'], df['Y'])]
  contador = 0

  for i in range(len(points)):
      x1, y1 = points[i]
      for j in range(i + 1, len(points)):
          x2, y2 = points[j]
          dist = distancia(x1, y1, x2, y2)
          if dist <= metros:
            contador += 1
  k = (area/len(points)**2)*contador
  return k

# Creación de la lista de la tabla hasta 200 m con aumento de 20 m
resultados = {'grupo': [], 'distancia_20': [], 'distancia_40': [], 'distancia_60': [], 'distancia_80': [], 'distancia_100': [], 'distancia_120': [], 'distancia_140': [], 'distancia_160': [], 'distancia_180': [], 'distancia_200': []}

# Iteración de DataFrame y calculo de K_Ripley
for nombre_df, dataframe in dataframes.items():
    resultados['grupo'].append(nombre_df)
    for metros in range(20, 201, 20):
        resultado = k_ripley2(dataframe, metros, area)
        resultados[f'distancia_{metros}'].append(resultado)


df_resultados = pd.DataFrame(resultados)

#Filtramos y guardamos las filas donde el valor de la columna tenga el nombre de la variable
fila_df_OG = df_resultados[df_resultados['grupo'] == 'df_OG']


#Filtrado de percentiles
percentiles_2_5 = df_resultados.filter(like='distancia_').quantile(0.025)
percentiles_97_5 = df_resultados.filter(like='distancia_').quantile(0.975)

# Crea un DataFrame  con los datos necesarios= Distancia,Percentiles y valor K
df_RES = pd.DataFrame({
    'distancia': [int(col.split('_')[-1]) for col in percentiles_2_5.index],
    'percentil_2.5': percentiles_2_5.values,
    'percentil_97.5': percentiles_97_5.values,
    'K': fila_df_OG.iloc[:, 1:].values.flatten()
})

# Ordena el DataFrame por valor de distancia de menor a mayor
df_RES = df_RES.sort_values(by='distancia')

# Muestra el DataFrame
df_RES

#Creamos un "Mapa" con 10 pulgadas de ancho y 6 de alto
plt.figure(figsize=(10, 6))
#Caracterizamos cada valor de los datos anteriormente mencionados y les ponemos etiquetas como;Nombre, color y tamaño
plt.plot(df_RES['distancia'], df_RES['K'], label='Valor Real', color='blue', marker='o')
plt.plot(df_RES['distancia'], df_RES['percentil_97.5'], label='Percentil 97.5', color='green', linestyle='-.')
plt.plot(df_RES['distancia'], df_RES['percentil_2.5'], label='Percentil 2.5', color='red', linestyle='dashed')

# Etiquetas visuales de la gráfica
plt.xlabel('Distancia entre puntos (Metros)')
plt.ylabel('Valor K')
plt.title('Valor K de distribución del Dengue en Floridablanca')
plt.legend()

# Imprimimos la grafica ya editada
plt.show()